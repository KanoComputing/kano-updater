#!/usr/bin/env python
#
# kano-updater
#
# Copyright (C) 2015 Kano Computing Ltd.
# License: http://www.gnu.org/licenses/gpl-2.0.txt GNU GPL v2
#

"""
kano-updater will help you keep your Kano OS up-to-date.

Usage:
  kano-updater check [--gui] [--interval <time>] [--urgent]
  kano-updater download [--low-prio]
  kano-updater install [--gui [--no-confirm] [--splash-pid <pid>]]
  kano-updater set-state <state>
  kano-updater set-scheduled (1|0)
  kano-updater first-boot
  kano-updater clean
  kano-updater ui (relaunch-splash <parent-pid> | boot-window | shutdown-window)
  kano-updater [-f] [-n]

Options:
  -h, --help       Show this message.
  -v, --version    Print the version of the updater.
  -g, --gui        Run the install procedure with a GUI.
  --no-confirm     Don't confirm before installing
  -l, --low-prio   Run the process with low shed and io priority.
  --interval       Minimum time interval between checks (in hours)
"""


import os
import sys
import atexit
import time
import signal

if __name__ == '__main__' and __package__ is None:
    DIR_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    if DIR_PATH != '/usr':
        sys.path.insert(0, DIR_PATH)
        LOCALE_PATH = os.path.join(DIR_PATH, 'locale')
    else:
        LOCALE_PATH = None

import kano_i18n.init
kano_i18n.init.install('kano-updater', LOCALE_PATH)

from kano.utils import enforce_root
from kano.logging import logger
from kano.gtk3.kano_dialog import KanoDialog

from kano_updater.os_version import TARGET_VERSION
from kano_updater.commands.download import download
from kano_updater.commands.install import install
from kano_updater.commands.check import check_for_updates
from kano_updater.commands.clean import clean
from kano_updater.progress import CLIProgress, Relaunch
from kano_updater.status import UpdaterStatus
from kano_updater.utils import make_low_prio, install_docopt, is_running, \
    remove_pid_file, pause_notifications, resume_notifications, show_kano_dialog
import kano_updater.priority as Priority


def sigterm_on_download(signo, frame):
    status = UpdaterStatus.get_instance()
    if status.state == UpdaterStatus.DOWNLOADING_UPDATES:
        msg = 'Updater got SIGTERM  while downloading in the background'
        logger.debug(msg)
        # Download was interrupted, go back one state
        status.state = UpdaterStatus.UPDATES_AVAILABLE
    # Exit from the signal handler to trigger the atexit hook
    sys.exit(0)


def clean_up():
    remove_pid_file()

    status = UpdaterStatus.get_instance()
    status.notifications_muted = False
    status.save()

    resume_notifications()
    logger.flush()


def schedule_install(gui=False, confirm=True, splash_pid=None):
    status = UpdaterStatus.get_instance()

    # if install is already scheduled, do the install, otherwise, ask for scheduling
    if status.state == UpdaterStatus.UPDATES_DOWNLOADED and status.is_urgent:
        # stops the confirm window for urgent updates
        confirm = False

        title = "Updater"
        description = "Urgent updates have been downloaded! We'll need to install these as soon" \
                      " as possible to ensure the best experience."
        buttons = "INSTALL NOW:green:1,LATER:orange:0"
        install_now = show_kano_dialog(title, description, buttons)

        # schedule the install to happen at shutdown
        # prevents unscheduling if the user closes the dialog from the startbar
        status.is_scheduled = True
        status.save()

        # user clicked INSTALL NOW, abort install
        if install_now:
            run_install(gui, confirm, splash_pid)


def run_install(gui=False, confirm=True, splash_pid=None):
    if gui:
        pause_notifications()

        status = UpdaterStatus.get_instance()
        status.notifications_muted = True
        status.save()

        from kano_updater.ui.main import launch_install_gui

        try:
            launch_install_gui(confirm=confirm, splash_pid=splash_pid)
        except Relaunch as relaunch_exception:
            clean_up()
            cmd_args = ['kano-updater', 'install', '--gui', '--no-confirm']
            if relaunch_exception.pid:
                cmd_args += ['--splash-pid', str(relaunch_exception.pid)]
            os.execvp('kano-updater', cmd_args)
    else:
        try:
            progress = CLIProgress()
            install(progress, gui)
        except Relaunch:
            clean_up()
            os.execvp('kano-updater', ['kano-updater', 'install'])


def main():
    msg = _('Administrator priviledges are required to perform this operation')
    enforce_root("{}: {}".format(_('ERROR'), msg))

    # docopt wasn't installed by default prior Kano OS 1.3.3
    # It needs to be installed to make sure the updater runs
    install_docopt()
    import docopt

    args = docopt.docopt(__doc__, version=str(TARGET_VERSION))

    # We always want to keep the logs from updates
    logger.force_log_level('info')

    if not args['relaunch-splash'] and is_running():
        msg = _('An instance of Kano Updater is already running')
        logger.error(msg)
        sys.stderr.write("{}: {}\n".format(_('ERROR'), msg))
        sys.exit(1)

    # This is registered after the test for whether an updater was already
    # running, because it deletes the pid file.
    atexit.register(clean_up)

    if args['set-state']:
        status = UpdaterStatus.get_instance()
        status.state = args['<state>']
        status.save()
    elif args['set-scheduled']:
        status = UpdaterStatus.get_instance()
        status.is_scheduled = args['1']  # if 1 was supplied, is_scheduled becomes True, else False
        status.save()
    elif args['clean']:
        clean()
    elif args['ui']:
        if args['relaunch-splash']:
            from kano_updater.ui.main import launch_relaunch_countdown_gui
            launch_relaunch_countdown_gui(int(args['<parent-pid>']))
        elif args['boot-window']:
            status = UpdaterStatus.get_instance()

            if status.is_scheduled and status.is_urgent:
                clean()
                return run_install(gui=True, confirm=False)

            from kano_updater.ui.main import launch_boot_gui
            launch_boot_gui()

            if status.is_scheduled:
                run_install(gui=True, confirm=True)

        elif args['shutdown-window']:
            status = UpdaterStatus.get_instance()
            status.is_shutdown = True
            status.save()
            from kano_updater.ui.main import launch_shutdown_gui
            launch_shutdown_gui()
    elif args['first-boot']:
        # spoof the last_check timestamp to six days ago so the user won't
        # be prompted to update in the first day after boot
        status = UpdaterStatus.get_instance()
        six_days_ago = int(time.time() - 6 * 24 * 60 * 60)
        status.last_check = status.last_update = six_days_ago
        one_day_ago = int(time.time() - 24 * 60 * 60)
        status.last_check_urgent = one_day_ago
        status.save()
    else:
        clean()

        progress = CLIProgress()
        status = UpdaterStatus.get_instance()

        if args['download']:
            if args['--low-prio']:
                signal.signal(signal.SIGTERM, sigterm_on_download)
                make_low_prio()
            download(progress, gui=False)
            schedule_install(gui=True)
        elif args['install']:
            splash_pid = None
            if args['--splash-pid']:
                splash_pid = int(args['<pid>'])

            run_install(gui=args['--gui'], confirm=not args['--no-confirm'],
                        splash_pid=splash_pid)
        elif args['check']:
            if args['--interval']:
                target_delta = float(args['<time>']) * 60 * 60

                time_now = time.time()
                delta = time_now - status.last_check

                if delta > target_delta:
                    logger.info(_('Time check passed, doing update check!'))
                else:
                    msg = _('Not enough time passed for a new update check!')
                    logger.warn(msg)
                    progress.abort(msg)

                    # Return if the check happened too early.
                    return 2

            priority = Priority.NONE

            if args['--urgent']:
                priority = Priority.URGENT

            # There used to be a dialog pop up if an update was found
            # that we had removed (see the commented out lines bellow).
            # if args['--gui']:
            #    from kano_updater.ui.main import launch_check_gui
            #    updates_available = launch_check_gui()
            # else:
            updates_available = check_for_updates(progress=progress,
                                                  priority=priority)

            if updates_available:
                status = UpdaterStatus.get_instance()
                if status.is_urgent:
                    logger.info(_('Urgent updates available.'))
                    progress = CLIProgress()
                    download(progress, gui=False)
                    schedule_install(gui=True)
                else:
                    logger.info(_('Updates available.'))
            else:
                if args['--gui']:
                    # Show dialogue
                    kdialog = KanoDialog(
                        "Updater",
                        "My brain already has the latest bits and bytes - high" \
                        " five!",
                        {
                            "OK": {
                                "return_value": True,
                                "color": "green"
                            },
                        },
                    )
                    kdialog.run()
                    del kdialog
                logger.info(_('No updates found.'))

            # Return 0 if there's an update, 1 if there isn't one
            return not updates_available
        else:
            # Launch the GUI if no arguments were given for
            # backwards compatiblity
            run_install(gui=True, confirm=False)

    return 0


if __name__ == '__main__':
    sys.exit(main())
